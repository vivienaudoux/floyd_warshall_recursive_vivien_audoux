#Importing the required modules
import unittest
import time

#Creating the 3 functions needed to create a recursive version of Floyd Warshall
def floyd_warshall_recursive(graph, dist, i, j, k):
    if k == -1:
        return dist[i][j]
    elif i == j:
        return 0
    else:
        without_k = floyd_warshall_recursive(graph, dist, i, j, k - 1)
        via_k = floyd_warshall_recursive(graph, dist, i, k, k - 1) + floyd_warshall_recursive(graph, dist, k, j, k - 1)
        return min(without_k, via_k)

def initialize_distance_matrix(graph):
    n = len(graph)
    dist = [[float('inf')] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i == j:
                dist[i][j] = 0
            elif graph[i][j] != 0:
                dist[i][j] = graph[i][j]
    return dist

def floyd_warshall(graph):
    n = len(graph)
    dist = initialize_distance_matrix(graph)
    for i in range(n):
        for j in range(n):
            dist[i][j] = floyd_warshall_recursive(graph, dist, i, j, n - 1)
    return dist

#Copy/pasting an imperative implementation of Floyd Marshall for testing purposes
#Code is copy/pasted from https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/
def floyd_warshall_imperative(graph):
    dist = list(map(lambda i: list(map(lambda j: j, i)), graph))
    for k in range(4):
        for i in range(4):
            for j in range(4):
                dist[i][j] = min(dist[i][j],
                                 dist[i][k] + dist[k][j]
                                 )
    return dist

#Creating a test graph to test the performance of the Floyd Warshall implementations
test_performance_graph = [
    [0, 5, float('inf'), 10],
    [float('inf'), 0, 3, float('inf')],
    [float('inf'), float('inf'), 0, 1],
    [float('inf'), float('inf'), float('inf'), 0]
]

#Testing the performance of the recursive form of Floyd Warshall
start_time = time.time()
result = floyd_warshall(test_performance_graph)
end_time = time.time()
exec_time_recursive = end_time - start_time
print("Floyd Warshall in recursive form takes:", '{:f}'.format(exec_time_recursive), "seconds")

#Testing the performance of the imperative form of Floyd Warshall
start_time = time.time()
result = floyd_warshall_imperative(test_performance_graph)
end_time = time.time()
exec_time_imperative = end_time - start_time
print("Floyd Warshall in imperative form takes:", '{:f}'.format(exec_time_imperative), "seconds")

#Comparing the performance of the imperative and recursive forms of Floyd Warshall
performance_difference = exec_time_recursive / exec_time_imperative
print("floyd_warshall in imperative form takes is", '{:.2f}'.format(performance_difference), "times faster")

#Defining unittest for the 3 functions that compose our recursive implementation of Floyd Warshall
class TestFloydWarshallRecursive(unittest.TestCase):

    def test_simple_graph(self):
        graph = {
            0: {1: 5, 2: 3},
            1: {2: 1},
            2: {}
        }
        dist = [
            [0, 5, 3],
            [float('inf'), 0, 1],
            [float('inf'), float('inf'), 0]
        ]
        self.assertEqual(floyd_warshall_recursive(graph, dist, 0, 2, 1), 3)

class TestInitializeDistanceMatrix(unittest.TestCase):

    def test_simple_graph(self):
        graph = [
            [0, 5, 3],
            [0, 0, 1],
            [0, 0, 0]
        ]
        expected_dist = [
            [0, 5, 3],
            [float('inf'), 0, 1],
            [float('inf'), float('inf'), 0]
        ]
        self.assertEqual(initialize_distance_matrix(graph), expected_dist)

class TestFloydWarshall(unittest.TestCase):

    def test_floyd_warshall(self):
        graph = [
            [0, 5, float('inf'), 10],
            [float('inf'), 0, 3, float('inf')],
            [float('inf'), float('inf'), 0, 1],
            [float('inf'), float('inf'), float('inf'), 0]
        ]

        expected_result = [
            [0, 5, 8, 9],
            [float('inf'), 0, 3, 4],
            [float('inf'), float('inf'), 0, 1],
            [float('inf'), float('inf'), float('inf'), 0]
        ]

        result = floyd_warshall(graph)
        self.assertEqual(result, expected_result)

if __name__ == '__main__':
    unittest.main()